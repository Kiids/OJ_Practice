/*
给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
示例 1：
输入：left = 5, right = 7
输出：4
示例 2：
输入：left = 0, right = 0
输出：0
示例 3：
输入：left = 1, right = 2147483647
输出：0
提示：
0 <= left <= right <= 2^31 - 1
*/

class Solution {
public:
    int rangeBitwiseAnd(int left, int right) {
        int mask = 1 << 30, ret = 0;                         // 最高位开始
        while (mask > 0 && (left & mask) == (right & mask))  // 寻找相同前缀
        {
            ret |= left & mask;
            mask >>= 1;
        }
        return ret;
    }
};

//两个位的值都为1，按位与的结果才为 1，否则为 0。
//得出：
//多个数字按位与，其结果中值为 1 的位只可能减少，其结果中值为 1 的位，在多个数字中的 对应位也为 1。
//有符号整型，忽略符号位剩 31 位从高位到低位依次 0, 1, 2, 3, ... 29, 30。
//首先寻找 n 和 m 二进制最长相同前缀长度为 x。
//加法只会影响连续的低位，所以 [n,m] 中的所有数字的长度为 x 的二进制前缀都是相等的。
//按位与的结果的长度x的二进制前缀也相同。
//此时 x 有两种情况：
//情况一： x = 31。即 n 和 m 相等。答案 n&m。
//情况二：0 <= x < 31。因为 n >= m，所以 m 的第 x 位必然为 0，而 n 的第 x 为必然为 1。(不然就成 m >= n 了)
//从 n 的后缀 0abcd... 累加到 m 的后缀 1hijk... 这个过程中，
//不管abcd...，hijk... 取值如何，必然要经过 10000...
//0abcd... 和 10000... 使得答案中长度为 31-x 的后缀必然都为 0。

