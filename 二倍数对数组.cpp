/*
给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 <= i < len(arr) / 2，都有 arr[2 * i + 1] = 2 * arr[2 * i]” 时，返回 true；否则，返回 false。
示例 1：
输入：arr = [3,1,3,6]
输出：false
示例 2：
输入：arr = [2,1,2,6]
输出：false
示例 3：
输入：arr = [4,-2,2,-4]
输出：true
解释：可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]
提示：
0 <= arr.length <= 3 * 10^4
arr.length 是偶数
-10^5 <= arr[i] <= 10^5
*/

class Solution {
public:
    bool canReorderDoubled(vector<int>& arr) {
        sort(arr.begin(), arr.end());
        unordered_map<int, int> m;
        for (auto e: arr)
        {
            if (e % 2 == 0 && e > 0 && m[e / 2])
                m[e / 2]--;
            else if (e < 0 && m[e * 2])
                m[e * 2]--;
            else
                m[e]++;
        }

        for (auto e: m)
        {
            if (e.first == 0)
            {
                if (e.second % 2 == 0)
                    continue;
                return false;
            }
            if (e.second)
                return false;
        }
        return true;
    }
};

//对数字进行排序，假设只考虑正数，则对数组从小到大遍历，第一个元素一定是数对中小的一个；
//而如果一个数i可能是数对中大的一个，则必须要求我们之前已经遍历到这个数的一半。
//因此用一个计数器记录每个元素作为数对中的小数出现的情况，假设数字在计数器中无记录，则该数必然是小数，将计数器更新+1。
//反之，如果当前元素的一半在计数器中有所记录，则说明当前元素一定是数对中的大数。
//将其一半对应的计数器-1；表示找到一对数对。
//最后，如果仍有落单的元素在计数器中，说明合法配对方式不存在。
//由于0只能是自身的二倍，直接统计0的数量，如果可重组，则0的数量为偶数。
//对于负数，在排序之后优先遍历的是最小的负数，如果重组可行，则这个数一定是另一个数的两倍。
//因此遍历过程中考虑某个元素的两倍是否在计数器中存在，如果存在则消去，反之则更新计数器+1。

