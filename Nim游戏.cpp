/*
你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。
你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。
示例:
输入: 4
输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
*/

class Solution {
public:
    bool canWinNim(int n) {
        return n % 4 != 0;
    }
};

//博弈问题，本质就是先手通过一系列操作，进来把当前状态变成对后手不利的状态。
//由于选手足够聪明和规则巧妙设计，先手在给出的状态下总是必胜或者必败的。
//必败态和必胜态的定义：
//必胜态：如果一个状态的后继状态中存在必败态，那么这种该状态下，先手必胜。
//必败态：如果一个状态的所有后继状态都是必胜态，那么这种状态下，先手必败。
//递归的定义
//必胜态的后继状态中只要要有一个必败态才可以。因为本题中一次可以取一到三块石子。
//故一个必败态 i，可以导致 i+1,i+2,i+3 为必胜态，而 i + 4 肯定是必败态。
//又因为 0 是最小的必败态，这样我们可以得出一个结论，当 n%4 == 0 时，先手必败，否则先手必胜。
