/*
给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。
重复出现的子串要计算它们出现的次数。
示例 1 :
输入: "00110011"
输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。
请注意，一些重复出现的子串要计算它们出现的次数。
另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。
示例 2 :
输入: "10101"
输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。
提示：
s.length 在1到50,000之间。
s 只包含“0”或“1”字符。
*/

class Solution {
public:
    int countBinarySubstrings(string s) {
        char last = '-';
        int ret = 0, pre = 0, cur = 0;
        s += '-';
        for (auto c : s)
        {
            if (last != c)
            {
                last = c;
                ret += min(pre, cur);
                pre = cur;
                cur = 0;
            }
            cur++;
        }
        return ret;
    }
};

//对于 000111 来说，符合要求的子串是 000111 0011 01
//不难发现，如果我们找到一段类似 000111 的数据，就可以用来统计答案
//即 这样前面是连续 0/1 后面是连续 1/0 的数据
//这一段的所有 3 个子串，取决于前面 0/1 的个数和后面 1/0 的个数
//即 min(cnt_pre, cnt_cur)
//遍历时，当数字再一次改变时（或到达结尾时），意味着一段结束，并能得到这一段前面和后面数字的个数。
//如 11101 来说，当我们遍历到最后的 1 时，1110 就是一段可以用来统计答案的数据
//而末尾的 01 则是另一段可以用来统计答案的数据
//对字符串结尾增加一个字符，可以将判断逻辑写在一个地方

class Solution {
public:
    int countBinarySubstrings(string s) {
        int pre = 0, cur = 1, ret = 0;
        for (int i = 1; i < s.size(); i++)
        {
            if (s[i] == s[i - 1])
                cur++;
            else
            {
                ret += min(pre, cur);
                pre = cur;
                cur = 1;
            }
        }
        ret += min(pre, cur);
        return ret;
    }
};

// 统计连续的0，1的个数， s=001110011，可以得到这样的counts 数组：counts={2,3,2,2}。
// 能组成的相同数量的连续0和1的字符串的个数，一定是counts中相邻两个数的最小数的数，
// 如2,3代表的字符串为“00111”，
// 可以拆分成满足题意的子串为01，0011，因此可以组成的子串个数为2=min(2,3)
// 遍历counts就可以得到结果，由于当前的结果只和上一个结果有关，因此用pre保存上一个结果。

