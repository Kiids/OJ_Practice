/*
你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。
示例 1：
输入：a = 2, b = [3]
输出：8
示例 2：
输入：a = 2, b = [1,0]
输出：1024
示例 3：
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
示例 4：
输入：a = 2147483647, b = [2,0,0]
输出：1198
提示：
1 <= a <= 2^31 - 1
1 <= b.length <= 2000
0 <= b[i] <= 9
b 不含前导 0
*/

class Solution {
    int mod = 1337;
    int Fun(int a, int b)
    {
        a %= mod;
        int t = 1;
        while(b)
        {
            if (b%2 == 1)
            {
                t *= a;
                t %= mod;
            }
            a *= a;
            a %= mod;
            b >>= 1;
        }
        return t;
    }
public:
    int superPow(int a, vector<int>& b) {
        if (b.size() == 0)
            return 1;
        int p = b.back();
        b.pop_back();
        return Fun(superPow(a, b), 10) * Fun(a, p) % mod;
    }
};

//a^1218 = a^(1210+8) = a^ 1210 * a^8 = (a^121)^10 * a^8
//因为数组表示的数字很大，不能直接用int或者long表示。不太方便直接使用快速幂。
//可以逐位进行幂次运算。 如上面的公式所示，1218次方=1210+8次方。1210可以拆成121*10，也就是先算121次方再进行10次幂计算。
//而121次方可以用同样的方法进行递归的计算。
//和快速幂的思想是接近的

