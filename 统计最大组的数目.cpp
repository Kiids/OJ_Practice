/*
给你一个整数 n 。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。
请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。
示例 1：
输入：n = 13
输出：4
解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：
[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。
示例 2：
输入：n = 2
输出：2
解释：总共有 2 个大小为 1 的组 [1]，[2]。
示例 3：
输入：n = 15
输出：6
示例 4：
输入：n = 24
输出：5
提示：
1 <= n <= 10^4
*/

class Solution {
public:
    int countLargestGroup(int n) {
        int hash[36] = {0}, tmp = 0, sum = 0, num = 0;
        for (int i = 1; i <= n; i++)
        {
            tmp = i, sum = 0;
            while (tmp)
            {
                sum = sum + tmp % 10;
                tmp /= 10;
            }
            hash[sum - 1]++;
        }
        sort(hash, hash + 36, greater<int>());
        for (; hash[num] == hash[0]; num ++);
        return num;
    }
};

/* 
首先由题可知，1 <= n <= 10^4，也就是说所有位数相加sum范围在1 ~ 36，所以36个数，可以取hash[36]
但注意：hash[0] 对应sum = 1
hash[1] 对应sum = 2,以此类推:hash[sum - 1] ++
eg:n = 13
1.i = 1 ~ 9, hash[1 ~ 9 - 1] = hash[0 ~ 8] = 1;
2.i = 10, hash[1 + 0 - 1] = hash[0] = 2;
3.i = 11, hash[1 + 1 - 1] = hash[1] = 2;
4.i = 12, hash[2] = 2;
5.i = 13, hash[3] = 2;
6.sort,从大到小排序
7.计数，和hash[0]一样大的
*/ 
