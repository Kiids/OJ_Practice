/*
如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。
我们给出一个由字符 '0' 和 '1' 组成的字符串 S，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。
返回使 S 单调递增的最小翻转次数。
示例 1：
输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
示例 2：
输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
示例 3：
输入："00011000"
输出：2
解释：我们翻转得到 00000000。
提示：
1 <= S.length <= 20000
S 中只包含字符 '0' 和 '1'
*/

class Solution {
public:
    int minFlipsMonoIncr(string s) {
        int n = s.length();
        vector<int> dp1(n, 0);  // 全部为0的次数 
        vector<int> dp2(n, 0);  // 全部为000...111的次数(可以没有1) 
        dp1[0] = (s[0] != '0');
        dp2[0] = 0;
        for (int i = 1; i < n; i++)
        {
            if (s[i] == '0')
                dp1[i] = dp1[i - 1];
            else
                dp1[i] = dp1[i - 1] + 1;

            if (s[i] == '0')
                dp2[i] = min(dp1[i - 1], dp2[i - 1] + 1);
            else
                dp2[i] = min(dp1[i - 1], dp2[i - 1]);
        }
        return dp2[n - 1];
    }
};
