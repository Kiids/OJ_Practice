/*
森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。
返回森林中兔子的最少数量。
示例:
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 "2" 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。
输入: answers = [10, 10, 10]
输出: 11
输入: answers = []
输出: 0
说明:
answers 的长度最大为1000。
answers[i] 是在 [0, 999] 范围内的整数。
*/

class Solution {
public:
    int numRabbits(vector<int>& answers) {
        if (answers.empty())
            return 0;

        int ret = 0;
        unordered_map<int, int> m;         // <数字， 说了这个数字的兔子数量>
        for (int e : answers)
        {
            if (!m.count(e) || m[e] == 0)  // 没有记录或当前数字的兔子数量为0时
            {
                ret += e + 1;
                m[e]++ ;
            }
            else if (m.count(e))
                m[e] ++ ;
            if (m[e] == e + 1)             // 当兔子数量等于数字时，表示达到该种颜色所能代表的数量上限
                m[e] = 0;                  // 重置兔子数量为零，若再遇到相同数字，需要开另一种颜色来存
        }
        return ret;
    }
};
