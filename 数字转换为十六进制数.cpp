/*
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
注意:
十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
示例 1：
输入:
26
输出:
"1a"
示例 2：
输入:
-1
输出:
"ffffffff"
*/

class Solution {
public:
    string toHex(int num) {
        string r = "";
        int flag = -1;
        string v[16] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
        if (num == 0)
            return "0";
        else if (num < 0)
            flag = 8;
        while (num)
        {
            if (flag == 0)
                break;
            int c = 0;
            c = (num & 0x0000000f);
            r = v[c] + r;
            num >>= 4;
            --flag;
        }
        return r;
    }
};
//二进制转十六进制的通常做法就是将目标数按四位分割，然后看每个四位的值赋予其相应的十六进制数值。
//通过(num & 0x0000000f)每次提取目标数的最后四位，根据hex数组获取相应的数值，得到后存储拼接在结果r中，
//然后num左移4位，去掉已经统计过的位数，便于截取新的“四位”。
//
//但左移4位对于负数有个问题，负数补码最高位为1，移位后会补1，不会变0，因此用一个flag来计数，只移动8次。
//至于为什么不正负数都直接循环8次，正数要用判零，是因为转十六进制高位都是0的话，正数固定循环8次就会在高位补零，
//这是不允许的。而对于负数，最高位肯定是1，不会出现高位都是零的情况。
